#include <Windows.h>
#include <iostream>
#include <stdlib.h>

using namespace std;

#define MaxSize 128 //预先分配空间，这个数值根据实际需要预估确定

typedef int ElemType;

typedef struct _SqStack {
	ElemType* base;  //栈底指针
	ElemType* top;  //栈顶指针
}SqStack;

bool InitStack(SqStack& S) {  //构造一个空栈S

	S.base = new ElemType[MaxSize];  //为顺序栈分配一个最大容量为Maxsize的空间

	if (!S.base) { //空间分配失败
		return false;
	}
	S.top = S.base; //top 初始为base，空栈
	return true;
}

bool PushStack(SqStack& S, ElemType e) {  // 插入元素e 为新的栈顶元素

	if (S.top - S.base == MaxSize) {  //栈满
		return false;
	}

	*(S.top++) = e;  //元素e 压入栈顶，然后栈顶指针加1，等价于*S.top=e; S.top++;

	return true;
}

bool PopStack(SqStack& S, ElemType& e)  //删除S 的栈顶元素，暂存在变量e中
{
	if (S.base == S.top) {  //栈空
		return false;
	}

	e = *(--S.top);  //栈顶指针减1，将栈顶元素赋给e

	return true;
}

//更优的版本
bool GetTop1(SqStack& S, ElemType& e) {  //返回S 的栈顶元素，栈顶指针不变

	if (S.top != S.base) {  //栈非空
		e = *(S.top - 1);  //返回栈顶元素的值，栈顶指针不变
		return true;
	}
	else {
		return false;
	}
}

ElemType GetTop(SqStack& S) {  //返回S 的栈顶元素，栈顶指针不变

	if (S.top != S.base) {  //栈非空
		return *(S.top - 1);  //返回栈顶元素的值，栈顶指针不变
	}
	else {
		return -1;
	}
}

int GetSize(SqStack& S) {  //返回栈中元素个数
	return (S.top - S.base);
}

bool IsEmpty(SqStack& S) {  //判断栈是否为空
	if (S.top == S.base) {
		return true;
	}
	else {
		return false;
	}
}

void DestoryStack(SqStack& S) {
	if (S.base) {
		free(S.base);
		S.base = NULL;
		S.top = NULL;
	}
}

int main(void) {
	int n, x;
	SqStack S;
	InitStack(S);  //初始化一个顺序栈S
	cout << "请输入元素个数n：" << endl;
	cin >> n;
	cout << "请依次输入n 个元素，依次入栈：" << endl;
	while (n--) {
		cin >> x;  //输入元素
		PushStack(S, x);
	}

	cout << "元素依次出栈：" << endl;
	while (!IsEmpty(S)) {  //如果栈不空，则依次出栈
		cout << GetTop(S) << "\t";  //输出栈顶元素
		PopStack(S, x);  //栈顶元素出栈
	}
	cout << endl;

	DestoryStack(S);
	system("pause");
	return 0;
}